// Generated by CoffeeScript 1.6.3
/*
  GamepadController with improved browser compatibility and edge case handling
  
  @class bkcore.GamepadController
  @author Mahesh Kulkarni <http://twitter.com/maheshkk>
*/


(function() {
  var GamepadController, exports, _base;

  GamepadController = (function() {
    GamepadController.isCompatible = function() {
      return ('getGamepads' in navigator) || ('webkitGetGamepads' in navigator) || ('mozGetGamepads' in navigator);
    };

    /*
      Creates a new GamepadController
    */


    function GamepadController(buttonPressCallback) {
      this.buttonPressCallback = buttonPressCallback;
      this.active = true;
      this.leftStickArray = [];
      this.rightStickArray = [];
      this.lastGamepadState = null;
      this.gamepadIndex = null;
      this.deadzone = 0.1; // Deadzone to prevent drift
      this.vibrationActuator = null;
    }

    /*
      @public - Update available gamepads and handle connection/disconnection
    */

    GamepadController.prototype.updateAvailable = function() {
      var accel, gamepads, gp, lt, rt, sel, _ref, _ref1, _ref2, _ref3;
      if (!this.active) {
        return false;
      }
      
      // Get gamepads using the available API
      gamepads = this._getGamepads();
      
      if (!gamepads || gamepads.length === 0) {
        this._onGamepadDisconnected();
        return false;
      }
      
      // Find the first connected gamepad if we don't have one yet
      if (this.gamepadIndex === null) {
        for (var i = 0; i < gamepads.length; i++) {
          if (gamepads[i] && gamepads[i].connected) {
            this.gamepadIndex = i;
            console.log('Gamepad connected:', gamepads[i].id);
            this._setupVibration(gamepads[i]);
            break;
          }
        }
      }
      
      // Check if our gamepad is still connected
      if (this.gamepadIndex !== null && (!gamepads[this.gamepadIndex] || !gamepads[this.gamepadIndex].connected)) {
        this._onGamepadDisconnected();
        return false;
      }
      
      gp = gamepads[this.gamepadIndex];
      if (!gp || !gp.buttons || !gp.axes) {
        return false;
      }
      
      // Apply deadzone to stick axes
      var leftStickX = this._applyDeadzone(gp.axes[0]);
      var leftStickY = this._applyDeadzone(gp.axes[1]);
      var rightStickX = this._applyDeadzone(gp.axes[2] || 0);
      var rightStickY = this._applyDeadzone(gp.axes[3] || 0);
      
      // Get button states with fallback for different button APIs
      var accel = this._getButtonState(gp.buttons[0]);
      var lt = this._getButtonState(gp.buttons[6] || gp.buttons[4]); // L1/L2 or LB/LT
      var rt = this._getButtonState(gp.buttons[7] || gp.buttons[5]); // R1/R2 or RB/RT
      var sel = this._getButtonState(gp.buttons[8] || gp.buttons[9]); // Select/Start or View/Menu
      
      // Update controller state
      this.lstickx = leftStickX;
      this.lsticky = leftStickY;
      this.rstickx = rightStickX;
      this.rsticky = rightStickY;
      this.acceleration = accel;
      this.ltrigger = lt;
      this.rtrigger = rt;
      this.select = sel;
      
      // Store current state for change detection
      var currentState = {
        lstickx: this.lstickx,
        lsticky: this.lsticky,
        rstickx: this.rstickx,
        rsticky: this.rsticky,
        acceleration: this.acceleration,
        ltrigger: this.ltrigger,
        rtrigger: this.rtrigger,
        select: this.select
      };
      
      // Only call callback if state has changed
      if (!this._statesEqual(currentState, this.lastGamepadState)) {
        this.lastGamepadState = currentState;
        if (this.buttonPressCallback) {
          this.buttonPressCallback(this);
        }
      }
      
      return true;
    };

    /*
      @private - Get gamepads using available API
    */

    GamepadController.prototype._getGamepads = function() {
      if (navigator.getGamepads) {
        return navigator.getGamepads();
      } else if (navigator.webkitGetGamepads) {
        return navigator.webkitGetGamepads();
      } else if (navigator.mozGetGamepads) {
        return navigator.mozGetGamepads();
      }
      return null;
    };

    /*
      @private - Apply deadzone to axis value
    */

    GamepadController.prototype._applyDeadzone = function(value) {
      if (Math.abs(value) < this.deadzone) {
        return 0;
      }
      return value;
    };

    /*
      @private - Get button state with fallback for different APIs
    */

    GamepadController.prototype._getButtonState = function(button) {
      if (!button) return false;
      
      if (typeof button === 'object') {
        // Modern gamepad API
        return button.pressed || false;
      } else if (typeof button === 'number') {
        // Older API (value as number)
        return button > 0;
      }
      return false;
    };

    /*
      @private - Compare two states for equality
    */

    GamepadController.prototype._statesEqual = function(state1, state2) {
      if (!state1 || !state2) return false;
      
      return state1.lstickx === state2.lstickx &&
             state1.lsticky === state2.lsticky &&
             state1.rstickx === state2.rstickx &&
             state1.rsticky === state2.rsticky &&
             state1.acceleration === state2.acceleration &&
             state1.ltrigger === state2.ltrigger &&
             state1.rtrigger === state2.rtrigger &&
             state1.select === state2.select;
    };

    /*
      @private - Handle gamepad disconnection
    */

    GamepadController.prototype._onGamepadDisconnected = function() {
      if (this.gamepadIndex !== null) {
        console.log('Gamepad disconnected');
        this.gamepadIndex = null;
        this.lastGamepadState = null;
        this.vibrationActuator = null;
      }
    };

    /*
      @private - Setup vibration if available
    */

    GamepadController.prototype._setupVibration = function(gamepad) {
      if (gamepad.vibrationActuator) {
        this.vibrationActuator = gamepad.vibrationActuator;
        console.log('Gamepad vibration supported');
      }
    };

    /*
      @public - Vibrate the gamepad if supported
    */

    GamepadController.prototype.vibrate = function(duration, intensity) {
      if (!this.vibrationActuator) return;
      
      try {
        this.vibrationActuator.playEffect('dual-rumble', {
          startDelay: 0,
          duration: duration || 200,
          weakMagnitude: intensity || 0.5,
          strongMagnitude: intensity || 0.5
        });
      } catch (error) {
        console.warn('Vibration failed:', error);
      }
    };

    /*
      @public - Check if any gamepad is connected
    */

    GamepadController.prototype.isConnected = function() {
      var gamepads = this._getGamepads();
      if (!gamepads) return false;
      
      for (var i = 0; i < gamepads.length; i++) {
        if (gamepads[i] && gamepads[i].connected) {
          return true;
        }
      }
      return false;
    };

    /*
      @public - Get info about connected gamepads
    */

    GamepadController.prototype.getGamepadInfo = function() {
      var gamepads = this._getGamepads();
      if (!gamepads) return [];
      
      var info = [];
      for (var i = 0; i < gamepads.length; i++) {
        if (gamepads[i] && gamepads[i].connected) {
          info.push({
            index: i,
            id: gamepads[i].id,
            mapping: gamepads[i].mapping,
            buttons: gamepads[i].buttons.length,
            axes: gamepads[i].axes.length
          });
        }
      }
      return info;
    };

    return GamepadController;

  })();

  exports = exports != null ? exports : this;

  exports.bkcore || (exports.bkcore = {});

  (_base = exports.bkcore).controllers || (_base.controllers = {});

  exports.bkcore.controllers.GamepadController = GamepadController;

}).call(this);