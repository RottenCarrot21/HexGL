// Generated by CoffeeScript 1.7.1

/*
  TouchController (stick + buttons) for touch devices with Pointer Events support
  Based on the touch demo by Seb Lee-Delisle <http://seb.ly/>
  Updated with Pointer Events and better iOS/Android compatibility
  
  @class bkcore.controllers.TouchController
  @author Thibaut 'BKcore' Despoulain <http://bkcore.com>
 */

(function() {
  var TouchController, Vec2, exports, _base;

  TouchController = (function() {
    TouchController.isCompatible = function() {
      return 'ontouchstart' in document.documentElement || 
             window.PointerEvent || 
             navigator.maxTouchPoints > 0;
    };

    /*
      Creates a new TouchController
    
      @param dom DOMElement The element that will listen to touch events
      @param stickMargin int The left margin in px for stick detection
      @param buttonCallback function Callback for non-stick touches
     */

    function TouchController(dom, stickMargin, buttonCallback) {
      this.dom = dom;
      this.stickMargin = stickMargin != null ? stickMargin : 200;
      this.buttonCallback = buttonCallback != null ? buttonCallback : null;
      this.active = true;
      this.touches = null;
      this.pointers = new Map(); // Track active pointers by ID
      this.stickID = -1;
      this.stickPos = new Vec2(0, 0);
      this.stickStartPos = new Vec2(0, 0);
      this.stickVector = new Vec2(0, 0);
      
      // Detect if we should use Pointer Events
      this.usePointerEvents = !!(window.PointerEvent || navigator.pointerEnabled || navigator.msPointerEnabled);
      
      if (this.usePointerEvents) {
        this._setupPointerEvents();
      } else {
        this._setupTouchEvents();
      }
      
      // Also handle mouse events for desktop testing
      this._setupMouseEvents();
    }

    /*
      @private
     */
    TouchController.prototype._setupPointerEvents = function() {
      var _this = this;
      
      // Normalize pointer event names
      var pointerDown = window.PointerEvent ? 'pointerdown' : 
                       navigator.msPointerEnabled ? 'MSPointerDown' : 'pointerdown';
      var pointerMove = window.PointerEvent ? 'pointermove' : 
                       navigator.msPointerEnabled ? 'MSPointerMove' : 'pointermove';
      var pointerUp = window.PointerEvent ? 'pointerup' : 
                     navigator.msPointerEnabled ? 'MSPointerUp' : 'pointerup';
      var pointerCancel = window.PointerEvent ? 'pointercancel' : 
                         navigator.msPointerEnabled ? 'MSPointerCancel' : 'pointercancel';
      
      this.dom.addEventListener(pointerDown, function(e) {
        return _this.pointerStart(e);
      }, false);
      
      this.dom.addEventListener(pointerMove, function(e) {
        return _this.pointerMove(e);
      }, false);
      
      this.dom.addEventListener(pointerUp, function(e) {
        return _this.pointerEnd(e);
      }, false);
      
      this.dom.addEventListener(pointerCancel, function(e) {
        return _this.pointerEnd(e);
      }, false);
      
      // Handle pointer leave for better iOS support
      this.dom.addEventListener('pointerleave', function(e) {
        return _this.pointerEnd(e);
      }, false);
    };

    /*
      @private
     */
    TouchController.prototype._setupTouchEvents = function() {
      var _this = this;
      
      this.dom.addEventListener('touchstart', function(e) {
        return _this.touchStart(e);
      }, { passive: false });
      
      this.dom.addEventListener('touchmove', function(e) {
        return _this.touchMove(e);
      }, { passive: false });
      
      this.dom.addEventListener('touchend', function(e) {
        return _this.touchEnd(e);
      }, { passive: false });
      
      this.dom.addEventListener('touchcancel', function(e) {
        return _this.touchEnd(e);
      }, { passive: false });
    };

    /*
      @private
     */
    TouchController.prototype._setupMouseEvents = function() {
      var _this = this;
      
      // Only use mouse events if touch isn't available (for desktop testing)
      if (!('ontouchstart' in document.documentElement)) {
        this.dom.addEventListener('mousedown', function(e) {
          return _this.mouseStart(e);
        }, false);
        
        this.dom.addEventListener('mousemove', function(e) {
          return _this.mouseMove(e);
        }, false);
        
        this.dom.addEventListener('mouseup', function(e) {
          return _this.mouseEnd(e);
        }, false);
      }
    };

    /*
      @private - Get coordinates from different event types
     */
    TouchController.prototype._getCoordinates = function(event) {
      if (event.touches) {
        // Touch event
        return {
          x: event.touches[0] || event.changedTouches[0] ? event.touches[0] ? event.touches[0].clientX : event.changedTouches[0].clientX : 0,
          y: event.touches[0] || event.changedTouches[0] ? event.touches[0] ? event.touches[0].clientY : event.changedTouches[0].clientY : 0,
          id: event.touches[0] ? event.touches[0].identifier : event.changedTouches[0].identifier
        };
      } else {
        // Pointer or mouse event
        return {
          x: event.clientX || 0,
          y: event.clientY || 0,
          id: event.pointerId || 1 // Use 1 for mouse
        };
      }
    };

    /*
      @private
     */

    TouchController.prototype.pointerStart = function(event) {
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.set(coords.id, coords);
      
      if (this.stickID < 0 && coords.x < this.stickMargin) {
        this.stickID = coords.id;
        this.stickStartPos.set(coords.x, coords.y);
        this.stickPos.copy(this.stickStartPos);
        this.stickVector.set(0, 0);
      } else {
        if (typeof this.buttonCallback === "function") {
          this.buttonCallback(true, coords, event);
        }
      }
      
      return false;
    };

    /*
      @private
     */

    TouchController.prototype.touchStart = function(event) {
      if (!this.active) {
        return;
      }
      
      var touch, _i, _len, _ref;
      _ref = event.changedTouches;
      
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        touch = _ref[_i];
        this.pointers.set(touch.identifier, {
          x: touch.clientX,
          y: touch.clientY,
          id: touch.identifier
        });
        
        if (this.stickID < 0 && touch.clientX < this.stickMargin) {
          this.stickID = touch.identifier;
          this.stickStartPos.set(touch.clientX, touch.clientY);
          this.stickPos.copy(this.stickStartPos);
          this.stickVector.set(0, 0);
          continue;
        } else {
          if (typeof this.buttonCallback === "function") {
            this.buttonCallback(true, touch, event);
          }
        }
      }
      
      this.touches = event.touches;
      return false;
    };

    /*
      @private - Mouse events for desktop testing
     */
    TouchController.prototype.mouseStart = function(event) {
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.set(coords.id, coords);
      
      if (this.stickID < 0 && coords.x < this.stickMargin) {
        this.stickID = coords.id;
        this.stickStartPos.set(coords.x, coords.y);
        this.stickPos.copy(this.stickStartPos);
        this.stickVector.set(0, 0);
      } else {
        if (typeof this.buttonCallback === "function") {
          this.buttonCallback(true, coords, event);
        }
      }
      
      return false;
    };

    /*
      @private
     */

    TouchController.prototype.pointerMove = function(event) {
      event.preventDefault();
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.set(coords.id, coords);
      
      if (this.stickID === coords.id && coords.x < this.stickMargin) {
        this.stickPos.set(coords.x, coords.y);
        this.stickVector.copy(this.stickPos).substract(this.stickStartPos);
      }
      
      return false;
    };

    /*
      @private
     */

    TouchController.prototype.touchMove = function(event) {
      event.preventDefault();
      if (!this.active) {
        return;
      }
      
      var touch, _i, _len, _ref;
      _ref = event.changedTouches;
      
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        touch = _ref[_i];
        
        if (this.stickID === touch.identifier && touch.clientX < this.stickMargin) {
          this.stickPos.set(touch.clientX, touch.clientY);
          this.stickVector.copy(this.stickPos).substract(this.stickStartPos);
          break;
        }
      }
      
      this.touches = event.touches;
      return false;
    };

    /*
      @private - Mouse events for desktop testing
     */
    TouchController.prototype.mouseMove = function(event) {
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.set(coords.id, coords);
      
      if (this.stickID === coords.id && coords.x < this.stickMargin) {
        this.stickPos.set(coords.x, coords.y);
        this.stickVector.copy(this.stickPos).substract(this.stickStartPos);
      }
      
      return false;
    };

    /*
      @private
     */

    TouchController.prototype.pointerEnd = function(event) {
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.delete(coords.id);
      
      if (this.stickID === coords.id) {
        this.stickID = -1;
        this.stickVector.set(0, 0);
      } else {
        if (typeof this.buttonCallback === "function") {
          this.buttonCallback(false, coords, event);
        }
      }
      
      return false;
    };

    /*
      @private
     */

    TouchController.prototype.touchEnd = function(event) {
      if (!this.active) {
        return;
      }
      
      this.touches = event.touches;
      var touch, _i, _len, _ref;
      _ref = event.changedTouches;
      
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        touch = _ref[_i];
        this.pointers.delete(touch.identifier);
        
        if (this.stickID === touch.identifier) {
          this.stickID = -1;
          this.stickVector.set(0, 0);
          break;
        } else {
          if (typeof this.buttonCallback === "function") {
            this.buttonCallback(false, touch, event);
          }
        }
      }
      
      return false;
    };

    /*
      @private - Mouse events for desktop testing
     */
    TouchController.prototype.mouseEnd = function(event) {
      if (!this.active) {
        return;
      }
      
      var coords = this._getCoordinates(event);
      this.pointers.delete(coords.id);
      
      if (this.stickID === coords.id) {
        this.stickID = -1;
        this.stickVector.set(0, 0);
      } else {
        if (typeof this.buttonCallback === "function") {
          this.buttonCallback(false, coords, event);
        }
      }
      
      return false;
    };

    return TouchController;

  })();


  /*
    Internal class used for vector2
    @class Vec2
    @private
   */

  Vec2 = (function() {
    function Vec2(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    Vec2.prototype.substract = function(vec) {
      this.x -= vec.x;
      this.y -= vec.y;
      return this;
    };

    Vec2.prototype.copy = function(vec) {
      this.x = vec.x;
      this.y = vec.y;
      return this;
    };

    Vec2.prototype.set = function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    };

    return Vec2;

  })();


  /*
    Exports
    @package bkcore
   */

  exports = exports != null ? exports : this;

  exports.bkcore || (exports.bkcore = {});

  (_base = exports.bkcore).controllers || (_base.controllers = {});

  exports.bkcore.controllers.TouchController = TouchController;

}).call(this);